#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftStop,       sensorTouch)
#pragma config(Motor,  port1,           leftLift1,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightLift1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightLift2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftLift2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightDrive,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightLift3,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JonLib/PID.h"

void drivebase (int left, int right, int deadbands) {
	motor[leftDrive] = abs(left)<deadbands?0:left;
	motor[rightDrive] = abs(right)<deadbands?0:right;
}

void lift (int power) {
	motor[leftLift1]	= power;
	motor[leftLift2]	= power;

	motor[leftLift3]	= power;
	motor[rightLift1]	= power;
	motor[rightLift2]	= power;
	motor[rightLift3]	= power;
}

pid clawPID;
void clawControlInit () {
	clawPID.kP = 0.2;
	clawPID.kI = 0.01;
	clawPID.kD = 0.7;
	clawPID.target = SensorValue[clawPot];
}

int lastSensorValue;
task clawControl () {
	clawControlInit();
	while(true) {
		clawPID.error = SensorValue[clawPot] - clawPID.target;

		clawPID.integral += clawPID.error;
		if(clawPID.error == 0 || abs(clawPID.error)>200)
			clawPID.integral = 0;
		else if(abs(clawPID.error)>1000)
			clawPID.error = 1000;
		if(clawPID.derivative==0 && clawPID.integral==0)
			clawPID.target = SensorValue[clawPot];
		if(clawPID.integral>1500)
			clawPID.integral = 1500;

		clawPID.derivative = clawPID.error - clawPID.lastError;

		clawPID.lastError = clawPID.error;

		lastSensorValue = SensorValue[clawPot];

		motor[claw] = clawPID.kP*clawPID.error+clawPID.kI*clawPID.integral+clawPID.kD*clawPID.derivative;

		delay(25);
	}
}

bool clawMovingOut = false;
bool clawInMotion = false;

task main() {

	startTask(clawControl);

	while(true) {
		drivebase(vexRT[Ch3], vexRT[Ch2], 10);

		if (vexRT[Btn5U])
			lift(127);
		else if (vexRT[Btn5D] && !SensorValue[liftStop])
			lift(-127);
		else if (SensorValue[liftStop])
			lift(0);
		else
			lift(10);

		if(vexRT[Btn6U]) {
			if(clawMovingOut)
				clawPID.target = SensorValue[clawPot];
			clawPID.target = clawPID.target - 70;
			clawMovingOut = false;
			clawInMotion = true;
		} else if (vexRT[Btn6D]) {
			if(!clawMovingOut)
				clawPID.target = SensorValue[clawPot];
			clawPID.target = clawPID.target + 70;
			clawMovingOut = true;
			clawInMotion = true;
		} else if (clawInMotion) {
			clawInMotion = false;
			clawPID.target = SensorValue[clawPot]-((!clawMovingOut)*60);
		}

		delay(25);
	}
}
